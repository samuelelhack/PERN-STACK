CREAR MIDDLEWARE DE ERROR 

ESTO SE HACE PARA MANEJAR ERRORES, Y HACER MAS FACIL EL MANEJO DE ERRORES

se crea una ruta la cual va a recibir 4 parametros, err, req, res, next 
esto significa que al momento de en los archivos de ruta crear las funciones con next
esto se puede utilizar para el cath, usando el next y pasandole un parametro como lo puede ser
el error 

automaticamente el sistema sabe que debe llegar a la funcion del index que recibe 4 aprametros

¬øC√≥mo funciona next()?
Cuando un middleware termina su trabajo, tiene tres opciones:

Responder directamente al cliente con res.send(), res.json(), etc.
Llamar a next() para pasar el control al siguiente middleware.
Llamar a next(error) para manejar un error y pasarlo a un middleware de manejo de errores.
Ejemplo b√°sico de next()
Supongamos que tenemos un middleware que verifica si el usuario est√° autenticado. Si el usuario est√° autenticado, pasamos al siguiente middleware con next(). Si no, enviamos un error.

javascript
Copiar
Editar
const verificarAutenticacion = (req, res, next) => {
    const usuarioAutenticado = req.headers.authorization; 

    if (!usuarioAutenticado) {
        return res.status(401).json({ error: "No autorizado" }); 
    }

    next(); // Pasa al siguiente middleware o ruta
};

app.use(verificarAutenticacion);

app.get('/perfil', (req, res) => {
    res.json({ mensaje: "Bienvenido al perfil" });
});
üîπ Si el usuario tiene el token correcto, next() permite que la solicitud contin√∫e a la ruta /perfil.
üîπ Si el usuario no tiene el token, se detiene la ejecuci√≥n y se devuelve un error 401 No autorizado.

next(error) para manejo de errores
Si queremos manejar errores en un middleware, pasamos un argumento a next(error). Express detecta que es un error y lo env√≠a a un middleware especial para manejar errores.

Ejemplo de manejo de errores
javascript
Copiar
Editar
const verificarDatos = (req, res, next) => {
    const { nombre } = req.body;
    
    if (!nombre) {
        const error = new Error("El nombre es obligatorio");
        error.status = 400; // C√≥digo de error Bad Request
        return next(error); // Pasa el error al middleware de manejo de errores
    }

    next(); // Contin√∫a si todo est√° bien
};

app.post('/usuarios', verificarDatos, (req, res) => {
    res.json({ mensaje: "Usuario creado con √©xito" });
});

// Middleware de manejo de errores
app.use((err, req, res, next) => {
    res.status(err.status || 500).json({
        error: err.message || "Error interno del servidor"
    });
});
¬øQu√© sucede aqu√≠?
üîπ Si el usuario no env√≠a el campo nombre, se genera un error y se env√≠a a next(error).
üîπ Express detecta el error y lo env√≠a al middleware de manejo de errores, que responde con un c√≥digo de error y un mensaje.
üîπ Si todo est√° bien, la solicitud sigue su curso con next().

y como sabe express que es un error
ChatGPT dijo:
¬øC√≥mo sabe Express que es un error? ü§î
En Express, un middleware normal tiene esta estructura:

javascript
Copiar
Editar
(req, res, next) => { /* l√≥gica aqu√≠ */ }
Mientras que un middleware de manejo de errores tiene cuatro par√°metros:

javascript
Copiar
Editar
(err, req, res, next) => { /* maneja el error aqu√≠ */ }
üí° Express sabe que es un error porque el middleware tiene 4 par√°metros en lugar de 3.

1Ô∏è‚É£ Cuando llamamos a next(error)
Si en un middleware llamamos next(error), Express autom√°ticamente lo detecta como un error y salta todos los middleware normales, dirigi√©ndose directamente al middleware de manejo de errores.

üîπ Ejemplo de error intencional
javascript
Copiar
Editar
const express = require('express');
const app = express();

// Middleware que genera un error
app.get('/error', (req, res, next) => {
    const error = new Error("Algo sali√≥ mal");
    error.status = 500; // C√≥digo de estado HTTP
    next(error); // Pasamos el error al middleware de errores
});

// Middleware de manejo de errores
app.use((err, req, res, next) => {
    res.status(err.status || 500).json({
        mensaje: err.message || "Error interno del servidor"
    });
});

app.listen(3000, () => console.log("Servidor en puerto 3000"));
üîπ Si visitamos http://localhost:3000/error, Express detecta next(error) y salta cualquier otro middleware, dirigiendo la solicitud directamente al middleware de errores.

2Ô∏è‚É£ Cuando ocurre una excepci√≥n en un middleware
Si en un middleware ocurre un error inesperado, Express lo detecta solo si usamos next(error) para pasarlo.

javascript
Copiar
Editar
app.get('/crash', (req, res, next) => {
    try {
        throw new Error("Fall√≥ el servidor"); // Simulamos un error
    } catch (error) {
        next(error); // Pasamos el error al middleware de errores
    }
});
üîπ Si no llamamos next(error), el error romper√≠a la aplicaci√≥n en lugar de manejarse correctamente.

3Ô∏è‚É£ Express ignora errores si no hay un middleware de manejo de errores
Si no definimos un middleware de errores y llamamos next(error), Express simplemente mostrar√° un error gen√©rico en el servidor, pero no enviar√° una respuesta adecuada al cliente.

Por eso, siempre debemos definir un middleware de manejo de errores al final de nuestras rutas.

¬øC√≥mo funciona throw new Error('ALGO FUE MAL') en JavaScript?
En JavaScript, la sentencia throw se usa para lanzar errores manualmente. Cuando usamos throw new Error('ALGO FUE MAL'), estamos creando y lanzando un objeto de error que detendr√° la ejecuci√≥n del c√≥digo a menos que sea manejado con un try...catch.

1Ô∏è‚É£ ¬øQu√© hace throw new Error('ALGO FUE MAL')?
Cuando se ejecuta esta l√≠nea:

javascript
Copiar
Editar
throw new Error('ALGO FUE MAL');
üí• Se detiene inmediatamente la ejecuci√≥n del c√≥digo y se genera un objeto de error con el mensaje 'ALGO FUE MAL'.

Ejemplo b√°sico:

javascript
Copiar
Editar
console.log("Antes del error");

throw new Error("ALGO FUE MAL"); // üö® Detiene la ejecuci√≥n aqu√≠

console.log("Despu√©s del error"); // ‚ùå Nunca se ejecutar√°


VARIABLES DE ENTORNO Y CORS

 (ESTO SE UTILIZA PARA AL MOMENTO DE COMPRATIR EL CODIGO
O MONTARLO EN GITHUB NO SE VEAN ESAS CREDENCIALES)

instalar npm i dotenv para esto lo que es permitirnos crear un archivo 
.env en nuestro proyecto 

const { config } = require('dotenv'); // Importamos el m√≥dulo dotenv
config();
se utiliza para cargar variables de entorno desde un archivo .env en una aplicaci√≥n Node.js.

üìå ¬øPara qu√© sirve?
Sirve para mantener informaci√≥n sensible o configurable fuera del c√≥digo fuente, como:

Credenciales de bases de datos (DB_USER, DB_PASSWORD)
Claves de API (API_KEY)
Configuraciones del servidor (PORT)
üõ†Ô∏è ¬øC√≥mo funciona?
1Ô∏è‚É£ Instalar dotenv (si no est√° instalado):

nginx
Copiar
Editar
npm install dotenv
2Ô∏è‚É£ Crear un archivo .env en la ra√≠z del proyecto:

ini
Copiar
Editar
PORT=3000
DB_USER=admin
DB_PASSWORD=secreto123
3Ô∏è‚É£ Cargar y usar las variables en Node.js:

javascript
Copiar
Editar
const { config } = require('dotenv');
config(); // Carga las variables del archivo .env

console.log(process.env.PORT); // 3000
console.log(process.env.DB_USER); // admin
console.log(process.env.DB_PASSWORD); // secreto123
üîé ¬øC√≥mo dotenv lo hace posible?
1Ô∏è‚É£ config() lee el archivo .env
2Ô∏è‚É£ Guarda las variables en process.env, que es un objeto global en Node.js
3Ô∏è‚É£ Podemos acceder a estas variables en cualquier parte de la app con process.env.NOMBRE_VARIABLE



